/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.19.1
 * source: types.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export class Id extends pb_1.Message {
    #one_of_decls: number[][] = [[1]];
    constructor(data?: any[] | ({} & (({
        id?: number;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("id" in data && data.id != undefined) {
                this.id = data.id;
            }
        }
    }
    get id() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set id(value: number) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_id() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get _id() {
        const cases: {
            [index: number]: "none" | "id";
        } = {
            0: "none",
            1: "id"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    static fromObject(data: {
        id?: number;
    }): Id {
        const message = new Id({});
        if (data.id != null) {
            message.id = data.id;
        }
        return message;
    }
    toObject() {
        const data: {
            id?: number;
        } = {};
        if (this.id != null) {
            data.id = this.id;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_id)
            writer.writeUint64(1, this.id);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Id {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Id();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.id = reader.readUint64();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Id {
        return Id.deserialize(bytes);
    }
}
export class Handle extends pb_1.Message {
    #one_of_decls: number[][] = [[1]];
    constructor(data?: any[] | ({} & (({
        handle?: number;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("handle" in data && data.handle != undefined) {
                this.handle = data.handle;
            }
        }
    }
    get handle() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set handle(value: number) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_handle() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get _handle() {
        const cases: {
            [index: number]: "none" | "handle";
        } = {
            0: "none",
            1: "handle"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    static fromObject(data: {
        handle?: number;
    }): Handle {
        const message = new Handle({});
        if (data.handle != null) {
            message.handle = data.handle;
        }
        return message;
    }
    toObject() {
        const data: {
            handle?: number;
        } = {};
        if (this.handle != null) {
            data.handle = this.handle;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_handle)
            writer.writeUint64(1, this.handle);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Handle {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Handle();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.handle = reader.readUint64();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Handle {
        return Handle.deserialize(bytes);
    }
}
export class Point extends pb_1.Message {
    #one_of_decls: number[][] = [[1], [2]];
    constructor(data?: any[] | ({} & (({
        x?: number;
    }) | ({
        y?: number;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("x" in data && data.x != undefined) {
                this.x = data.x;
            }
            if ("y" in data && data.y != undefined) {
                this.y = data.y;
            }
        }
    }
    get x() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set x(value: number) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_x() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get y() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set y(value: number) {
        pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
    }
    get has_y() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get _x() {
        const cases: {
            [index: number]: "none" | "x";
        } = {
            0: "none",
            1: "x"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    get _y() {
        const cases: {
            [index: number]: "none" | "y";
        } = {
            0: "none",
            2: "y"
        };
        return cases[pb_1.Message.computeOneofCase(this, [2])];
    }
    static fromObject(data: {
        x?: number;
        y?: number;
    }): Point {
        const message = new Point({});
        if (data.x != null) {
            message.x = data.x;
        }
        if (data.y != null) {
            message.y = data.y;
        }
        return message;
    }
    toObject() {
        const data: {
            x?: number;
            y?: number;
        } = {};
        if (this.x != null) {
            data.x = this.x;
        }
        if (this.y != null) {
            data.y = this.y;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_x)
            writer.writeInt32(1, this.x);
        if (this.has_y)
            writer.writeInt32(2, this.y);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Point {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Point();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.x = reader.readInt32();
                    break;
                case 2:
                    message.y = reader.readInt32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Point {
        return Point.deserialize(bytes);
    }
}
export class Size extends pb_1.Message {
    #one_of_decls: number[][] = [[1], [2]];
    constructor(data?: any[] | ({} & (({
        width?: number;
    }) | ({
        height?: number;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("width" in data && data.width != undefined) {
                this.width = data.width;
            }
            if ("height" in data && data.height != undefined) {
                this.height = data.height;
            }
        }
    }
    get width() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set width(value: number) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_width() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get height() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set height(value: number) {
        pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
    }
    get has_height() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get _width() {
        const cases: {
            [index: number]: "none" | "width";
        } = {
            0: "none",
            1: "width"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    get _height() {
        const cases: {
            [index: number]: "none" | "height";
        } = {
            0: "none",
            2: "height"
        };
        return cases[pb_1.Message.computeOneofCase(this, [2])];
    }
    static fromObject(data: {
        width?: number;
        height?: number;
    }): Size {
        const message = new Size({});
        if (data.width != null) {
            message.width = data.width;
        }
        if (data.height != null) {
            message.height = data.height;
        }
        return message;
    }
    toObject() {
        const data: {
            width?: number;
            height?: number;
        } = {};
        if (this.width != null) {
            data.width = this.width;
        }
        if (this.height != null) {
            data.height = this.height;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_width)
            writer.writeInt32(1, this.width);
        if (this.has_height)
            writer.writeInt32(2, this.height);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Size {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Size();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.width = reader.readInt32();
                    break;
                case 2:
                    message.height = reader.readInt32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Size {
        return Size.deserialize(bytes);
    }
}
export class Rect extends pb_1.Message {
    #one_of_decls: number[][] = [[1], [2]];
    constructor(data?: any[] | ({} & (({
        xy?: Point;
    }) | ({
        wh?: Size;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("xy" in data && data.xy != undefined) {
                this.xy = data.xy;
            }
            if ("wh" in data && data.wh != undefined) {
                this.wh = data.wh;
            }
        }
    }
    get xy() {
        return pb_1.Message.getWrapperField(this, Point, 1) as Point;
    }
    set xy(value: Point) {
        pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_xy() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get wh() {
        return pb_1.Message.getWrapperField(this, Size, 2) as Size;
    }
    set wh(value: Size) {
        pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[1], value);
    }
    get has_wh() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get _xy() {
        const cases: {
            [index: number]: "none" | "xy";
        } = {
            0: "none",
            1: "xy"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    get _wh() {
        const cases: {
            [index: number]: "none" | "wh";
        } = {
            0: "none",
            2: "wh"
        };
        return cases[pb_1.Message.computeOneofCase(this, [2])];
    }
    static fromObject(data: {
        xy?: ReturnType<typeof Point.prototype.toObject>;
        wh?: ReturnType<typeof Size.prototype.toObject>;
    }): Rect {
        const message = new Rect({});
        if (data.xy != null) {
            message.xy = Point.fromObject(data.xy);
        }
        if (data.wh != null) {
            message.wh = Size.fromObject(data.wh);
        }
        return message;
    }
    toObject() {
        const data: {
            xy?: ReturnType<typeof Point.prototype.toObject>;
            wh?: ReturnType<typeof Size.prototype.toObject>;
        } = {};
        if (this.xy != null) {
            data.xy = this.xy.toObject();
        }
        if (this.wh != null) {
            data.wh = this.wh.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_xy)
            writer.writeMessage(1, this.xy, () => this.xy.serialize(writer));
        if (this.has_wh)
            writer.writeMessage(2, this.wh, () => this.wh.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Rect {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Rect();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.xy, () => message.xy = Point.deserialize(reader));
                    break;
                case 2:
                    reader.readMessage(message.wh, () => message.wh = Size.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Rect {
        return Rect.deserialize(bytes);
    }
}
export class Callback extends pb_1.Message {
    #one_of_decls: number[][] = [[1], [2]];
    constructor(data?: any[] | ({} & (({
        msg?: string;
    }) | ({
        detail?: string;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("msg" in data && data.msg != undefined) {
                this.msg = data.msg;
            }
            if ("detail" in data && data.detail != undefined) {
                this.detail = data.detail;
            }
        }
    }
    get msg() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set msg(value: string) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_msg() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get detail() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set detail(value: string) {
        pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
    }
    get has_detail() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get _msg() {
        const cases: {
            [index: number]: "none" | "msg";
        } = {
            0: "none",
            1: "msg"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    get _detail() {
        const cases: {
            [index: number]: "none" | "detail";
        } = {
            0: "none",
            2: "detail"
        };
        return cases[pb_1.Message.computeOneofCase(this, [2])];
    }
    static fromObject(data: {
        msg?: string;
        detail?: string;
    }): Callback {
        const message = new Callback({});
        if (data.msg != null) {
            message.msg = data.msg;
        }
        if (data.detail != null) {
            message.detail = data.detail;
        }
        return message;
    }
    toObject() {
        const data: {
            msg?: string;
            detail?: string;
        } = {};
        if (this.msg != null) {
            data.msg = this.msg;
        }
        if (this.detail != null) {
            data.detail = this.detail;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_msg)
            writer.writeString(1, this.msg);
        if (this.has_detail)
            writer.writeString(2, this.detail);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Callback {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Callback();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.msg = reader.readString();
                    break;
                case 2:
                    message.detail = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Callback {
        return Callback.deserialize(bytes);
    }
}
export class ClickParam extends pb_1.Message {
    #one_of_decls: number[][] = [[1]];
    constructor(data?: any[] | ({} & (({
        point?: Point;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("point" in data && data.point != undefined) {
                this.point = data.point;
            }
        }
    }
    get point() {
        return pb_1.Message.getWrapperField(this, Point, 1) as Point;
    }
    set point(value: Point) {
        pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_point() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get _point() {
        const cases: {
            [index: number]: "none" | "point";
        } = {
            0: "none",
            1: "point"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    static fromObject(data: {
        point?: ReturnType<typeof Point.prototype.toObject>;
    }): ClickParam {
        const message = new ClickParam({});
        if (data.point != null) {
            message.point = Point.fromObject(data.point);
        }
        return message;
    }
    toObject() {
        const data: {
            point?: ReturnType<typeof Point.prototype.toObject>;
        } = {};
        if (this.point != null) {
            data.point = this.point.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_point)
            writer.writeMessage(1, this.point, () => this.point.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ClickParam {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ClickParam();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.point, () => message.point = Point.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ClickParam {
        return ClickParam.deserialize(bytes);
    }
}
export class SwipeParam extends pb_1.Message {
    #one_of_decls: number[][] = [[1], [2], [3]];
    constructor(data?: any[] | ({} & (({
        from?: Point;
    }) | ({
        to?: Point;
    }) | ({
        duration?: number;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("from" in data && data.from != undefined) {
                this.from = data.from;
            }
            if ("to" in data && data.to != undefined) {
                this.to = data.to;
            }
            if ("duration" in data && data.duration != undefined) {
                this.duration = data.duration;
            }
        }
    }
    get from() {
        return pb_1.Message.getWrapperField(this, Point, 1) as Point;
    }
    set from(value: Point) {
        pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_from() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get to() {
        return pb_1.Message.getWrapperField(this, Point, 2) as Point;
    }
    set to(value: Point) {
        pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[1], value);
    }
    get has_to() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get duration() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set duration(value: number) {
        pb_1.Message.setOneofField(this, 3, this.#one_of_decls[2], value);
    }
    get has_duration() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get _from() {
        const cases: {
            [index: number]: "none" | "from";
        } = {
            0: "none",
            1: "from"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    get _to() {
        const cases: {
            [index: number]: "none" | "to";
        } = {
            0: "none",
            2: "to"
        };
        return cases[pb_1.Message.computeOneofCase(this, [2])];
    }
    get _duration() {
        const cases: {
            [index: number]: "none" | "duration";
        } = {
            0: "none",
            3: "duration"
        };
        return cases[pb_1.Message.computeOneofCase(this, [3])];
    }
    static fromObject(data: {
        from?: ReturnType<typeof Point.prototype.toObject>;
        to?: ReturnType<typeof Point.prototype.toObject>;
        duration?: number;
    }): SwipeParam {
        const message = new SwipeParam({});
        if (data.from != null) {
            message.from = Point.fromObject(data.from);
        }
        if (data.to != null) {
            message.to = Point.fromObject(data.to);
        }
        if (data.duration != null) {
            message.duration = data.duration;
        }
        return message;
    }
    toObject() {
        const data: {
            from?: ReturnType<typeof Point.prototype.toObject>;
            to?: ReturnType<typeof Point.prototype.toObject>;
            duration?: number;
        } = {};
        if (this.from != null) {
            data.from = this.from.toObject();
        }
        if (this.to != null) {
            data.to = this.to.toObject();
        }
        if (this.duration != null) {
            data.duration = this.duration;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_from)
            writer.writeMessage(1, this.from, () => this.from.serialize(writer));
        if (this.has_to)
            writer.writeMessage(2, this.to, () => this.to.serialize(writer));
        if (this.has_duration)
            writer.writeInt32(3, this.duration);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SwipeParam {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SwipeParam();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.from, () => message.from = Point.deserialize(reader));
                    break;
                case 2:
                    reader.readMessage(message.to, () => message.to = Point.deserialize(reader));
                    break;
                case 3:
                    message.duration = reader.readInt32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): SwipeParam {
        return SwipeParam.deserialize(bytes);
    }
}
export class KeyParam extends pb_1.Message {
    #one_of_decls: number[][] = [[1]];
    constructor(data?: any[] | ({} & (({
        key?: number;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("key" in data && data.key != undefined) {
                this.key = data.key;
            }
        }
    }
    get key() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set key(value: number) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_key() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get _key() {
        const cases: {
            [index: number]: "none" | "key";
        } = {
            0: "none",
            1: "key"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    static fromObject(data: {
        key?: number;
    }): KeyParam {
        const message = new KeyParam({});
        if (data.key != null) {
            message.key = data.key;
        }
        return message;
    }
    toObject() {
        const data: {
            key?: number;
        } = {};
        if (this.key != null) {
            data.key = this.key;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_key)
            writer.writeInt32(1, this.key);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): KeyParam {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new KeyParam();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.key = reader.readInt32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): KeyParam {
        return KeyParam.deserialize(bytes);
    }
}
export class TouchParam extends pb_1.Message {
    #one_of_decls: number[][] = [[1], [2], [3]];
    constructor(data?: any[] | ({} & (({
        contact?: number;
    }) | ({
        pos?: Point;
    }) | ({
        pressure?: number;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("contact" in data && data.contact != undefined) {
                this.contact = data.contact;
            }
            if ("pos" in data && data.pos != undefined) {
                this.pos = data.pos;
            }
            if ("pressure" in data && data.pressure != undefined) {
                this.pressure = data.pressure;
            }
        }
    }
    get contact() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set contact(value: number) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_contact() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get pos() {
        return pb_1.Message.getWrapperField(this, Point, 2) as Point;
    }
    set pos(value: Point) {
        pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[1], value);
    }
    get has_pos() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get pressure() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set pressure(value: number) {
        pb_1.Message.setOneofField(this, 3, this.#one_of_decls[2], value);
    }
    get has_pressure() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get _contact() {
        const cases: {
            [index: number]: "none" | "contact";
        } = {
            0: "none",
            1: "contact"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    get _pos() {
        const cases: {
            [index: number]: "none" | "pos";
        } = {
            0: "none",
            2: "pos"
        };
        return cases[pb_1.Message.computeOneofCase(this, [2])];
    }
    get _pressure() {
        const cases: {
            [index: number]: "none" | "pressure";
        } = {
            0: "none",
            3: "pressure"
        };
        return cases[pb_1.Message.computeOneofCase(this, [3])];
    }
    static fromObject(data: {
        contact?: number;
        pos?: ReturnType<typeof Point.prototype.toObject>;
        pressure?: number;
    }): TouchParam {
        const message = new TouchParam({});
        if (data.contact != null) {
            message.contact = data.contact;
        }
        if (data.pos != null) {
            message.pos = Point.fromObject(data.pos);
        }
        if (data.pressure != null) {
            message.pressure = data.pressure;
        }
        return message;
    }
    toObject() {
        const data: {
            contact?: number;
            pos?: ReturnType<typeof Point.prototype.toObject>;
            pressure?: number;
        } = {};
        if (this.contact != null) {
            data.contact = this.contact;
        }
        if (this.pos != null) {
            data.pos = this.pos.toObject();
        }
        if (this.pressure != null) {
            data.pressure = this.pressure;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_contact)
            writer.writeInt32(1, this.contact);
        if (this.has_pos)
            writer.writeMessage(2, this.pos, () => this.pos.serialize(writer));
        if (this.has_pressure)
            writer.writeInt32(3, this.pressure);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TouchParam {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TouchParam();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.contact = reader.readInt32();
                    break;
                case 2:
                    reader.readMessage(message.pos, () => message.pos = Point.deserialize(reader));
                    break;
                case 3:
                    message.pressure = reader.readInt32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): TouchParam {
        return TouchParam.deserialize(bytes);
    }
}
export class EmptyRequest extends pb_1.Message {
    #one_of_decls: number[][] = [[1]];
    constructor(data?: any[] | ({} & (({
        unused?: boolean;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("unused" in data && data.unused != undefined) {
                this.unused = data.unused;
            }
        }
    }
    get unused() {
        return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
    }
    set unused(value: boolean) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_unused() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get _unused() {
        const cases: {
            [index: number]: "none" | "unused";
        } = {
            0: "none",
            1: "unused"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    static fromObject(data: {
        unused?: boolean;
    }): EmptyRequest {
        const message = new EmptyRequest({});
        if (data.unused != null) {
            message.unused = data.unused;
        }
        return message;
    }
    toObject() {
        const data: {
            unused?: boolean;
        } = {};
        if (this.unused != null) {
            data.unused = this.unused;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_unused)
            writer.writeBool(1, this.unused);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EmptyRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EmptyRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.unused = reader.readBool();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): EmptyRequest {
        return EmptyRequest.deserialize(bytes);
    }
}
export class IdRequest extends pb_1.Message {
    #one_of_decls: number[][] = [[1]];
    constructor(data?: any[] | ({} & (({
        id?: Id;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("id" in data && data.id != undefined) {
                this.id = data.id;
            }
        }
    }
    get id() {
        return pb_1.Message.getWrapperField(this, Id, 1) as Id;
    }
    set id(value: Id) {
        pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_id() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get _id() {
        const cases: {
            [index: number]: "none" | "id";
        } = {
            0: "none",
            1: "id"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    static fromObject(data: {
        id?: ReturnType<typeof Id.prototype.toObject>;
    }): IdRequest {
        const message = new IdRequest({});
        if (data.id != null) {
            message.id = Id.fromObject(data.id);
        }
        return message;
    }
    toObject() {
        const data: {
            id?: ReturnType<typeof Id.prototype.toObject>;
        } = {};
        if (this.id != null) {
            data.id = this.id.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_id)
            writer.writeMessage(1, this.id, () => this.id.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IdRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IdRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.id, () => message.id = Id.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): IdRequest {
        return IdRequest.deserialize(bytes);
    }
}
export class HandleRequest extends pb_1.Message {
    #one_of_decls: number[][] = [[1]];
    constructor(data?: any[] | ({} & (({
        handle?: Handle;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("handle" in data && data.handle != undefined) {
                this.handle = data.handle;
            }
        }
    }
    get handle() {
        return pb_1.Message.getWrapperField(this, Handle, 1) as Handle;
    }
    set handle(value: Handle) {
        pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_handle() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get _handle() {
        const cases: {
            [index: number]: "none" | "handle";
        } = {
            0: "none",
            1: "handle"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    static fromObject(data: {
        handle?: ReturnType<typeof Handle.prototype.toObject>;
    }): HandleRequest {
        const message = new HandleRequest({});
        if (data.handle != null) {
            message.handle = Handle.fromObject(data.handle);
        }
        return message;
    }
    toObject() {
        const data: {
            handle?: ReturnType<typeof Handle.prototype.toObject>;
        } = {};
        if (this.handle != null) {
            data.handle = this.handle.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_handle)
            writer.writeMessage(1, this.handle, () => this.handle.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HandleRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HandleRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.handle, () => message.handle = Handle.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): HandleRequest {
        return HandleRequest.deserialize(bytes);
    }
}
export class BufferRequest extends pb_1.Message {
    #one_of_decls: number[][] = [[1]];
    constructor(data?: any[] | ({} & (({
        buffer?: Uint8Array;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("buffer" in data && data.buffer != undefined) {
                this.buffer = data.buffer;
            }
        }
    }
    get buffer() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
    }
    set buffer(value: Uint8Array) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_buffer() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get _buffer() {
        const cases: {
            [index: number]: "none" | "buffer";
        } = {
            0: "none",
            1: "buffer"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    static fromObject(data: {
        buffer?: Uint8Array;
    }): BufferRequest {
        const message = new BufferRequest({});
        if (data.buffer != null) {
            message.buffer = data.buffer;
        }
        return message;
    }
    toObject() {
        const data: {
            buffer?: Uint8Array;
        } = {};
        if (this.buffer != null) {
            data.buffer = this.buffer;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_buffer)
            writer.writeBytes(1, this.buffer);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BufferRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BufferRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.buffer = reader.readBytes();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): BufferRequest {
        return BufferRequest.deserialize(bytes);
    }
}
export class HandleBufferRequest extends pb_1.Message {
    #one_of_decls: number[][] = [[1], [2]];
    constructor(data?: any[] | ({} & (({
        handle?: Handle;
    }) | ({
        buffer?: Uint8Array;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("handle" in data && data.handle != undefined) {
                this.handle = data.handle;
            }
            if ("buffer" in data && data.buffer != undefined) {
                this.buffer = data.buffer;
            }
        }
    }
    get handle() {
        return pb_1.Message.getWrapperField(this, Handle, 1) as Handle;
    }
    set handle(value: Handle) {
        pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_handle() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get buffer() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
    }
    set buffer(value: Uint8Array) {
        pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
    }
    get has_buffer() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get _handle() {
        const cases: {
            [index: number]: "none" | "handle";
        } = {
            0: "none",
            1: "handle"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    get _buffer() {
        const cases: {
            [index: number]: "none" | "buffer";
        } = {
            0: "none",
            2: "buffer"
        };
        return cases[pb_1.Message.computeOneofCase(this, [2])];
    }
    static fromObject(data: {
        handle?: ReturnType<typeof Handle.prototype.toObject>;
        buffer?: Uint8Array;
    }): HandleBufferRequest {
        const message = new HandleBufferRequest({});
        if (data.handle != null) {
            message.handle = Handle.fromObject(data.handle);
        }
        if (data.buffer != null) {
            message.buffer = data.buffer;
        }
        return message;
    }
    toObject() {
        const data: {
            handle?: ReturnType<typeof Handle.prototype.toObject>;
            buffer?: Uint8Array;
        } = {};
        if (this.handle != null) {
            data.handle = this.handle.toObject();
        }
        if (this.buffer != null) {
            data.buffer = this.buffer;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_handle)
            writer.writeMessage(1, this.handle, () => this.handle.serialize(writer));
        if (this.has_buffer)
            writer.writeBytes(2, this.buffer);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HandleBufferRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HandleBufferRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.handle, () => message.handle = Handle.deserialize(reader));
                    break;
                case 2:
                    message.buffer = reader.readBytes();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): HandleBufferRequest {
        return HandleBufferRequest.deserialize(bytes);
    }
}
export class HandleStringRequest extends pb_1.Message {
    #one_of_decls: number[][] = [[1], [2]];
    constructor(data?: any[] | ({} & (({
        handle?: Handle;
    }) | ({
        str?: string;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("handle" in data && data.handle != undefined) {
                this.handle = data.handle;
            }
            if ("str" in data && data.str != undefined) {
                this.str = data.str;
            }
        }
    }
    get handle() {
        return pb_1.Message.getWrapperField(this, Handle, 1) as Handle;
    }
    set handle(value: Handle) {
        pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_handle() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get str() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set str(value: string) {
        pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
    }
    get has_str() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get _handle() {
        const cases: {
            [index: number]: "none" | "handle";
        } = {
            0: "none",
            1: "handle"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    get _str() {
        const cases: {
            [index: number]: "none" | "str";
        } = {
            0: "none",
            2: "str"
        };
        return cases[pb_1.Message.computeOneofCase(this, [2])];
    }
    static fromObject(data: {
        handle?: ReturnType<typeof Handle.prototype.toObject>;
        str?: string;
    }): HandleStringRequest {
        const message = new HandleStringRequest({});
        if (data.handle != null) {
            message.handle = Handle.fromObject(data.handle);
        }
        if (data.str != null) {
            message.str = data.str;
        }
        return message;
    }
    toObject() {
        const data: {
            handle?: ReturnType<typeof Handle.prototype.toObject>;
            str?: string;
        } = {};
        if (this.handle != null) {
            data.handle = this.handle.toObject();
        }
        if (this.str != null) {
            data.str = this.str;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_handle)
            writer.writeMessage(1, this.handle, () => this.handle.serialize(writer));
        if (this.has_str)
            writer.writeString(2, this.str);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HandleStringRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HandleStringRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.handle, () => message.handle = Handle.deserialize(reader));
                    break;
                case 2:
                    message.str = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): HandleStringRequest {
        return HandleStringRequest.deserialize(bytes);
    }
}
export class HandleIdRequest extends pb_1.Message {
    #one_of_decls: number[][] = [[1], [2]];
    constructor(data?: any[] | ({} & (({
        handle?: Handle;
    }) | ({
        id?: Id;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("handle" in data && data.handle != undefined) {
                this.handle = data.handle;
            }
            if ("id" in data && data.id != undefined) {
                this.id = data.id;
            }
        }
    }
    get handle() {
        return pb_1.Message.getWrapperField(this, Handle, 1) as Handle;
    }
    set handle(value: Handle) {
        pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_handle() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get id() {
        return pb_1.Message.getWrapperField(this, Id, 2) as Id;
    }
    set id(value: Id) {
        pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[1], value);
    }
    get has_id() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get _handle() {
        const cases: {
            [index: number]: "none" | "handle";
        } = {
            0: "none",
            1: "handle"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    get _id() {
        const cases: {
            [index: number]: "none" | "id";
        } = {
            0: "none",
            2: "id"
        };
        return cases[pb_1.Message.computeOneofCase(this, [2])];
    }
    static fromObject(data: {
        handle?: ReturnType<typeof Handle.prototype.toObject>;
        id?: ReturnType<typeof Id.prototype.toObject>;
    }): HandleIdRequest {
        const message = new HandleIdRequest({});
        if (data.handle != null) {
            message.handle = Handle.fromObject(data.handle);
        }
        if (data.id != null) {
            message.id = Id.fromObject(data.id);
        }
        return message;
    }
    toObject() {
        const data: {
            handle?: ReturnType<typeof Handle.prototype.toObject>;
            id?: ReturnType<typeof Id.prototype.toObject>;
        } = {};
        if (this.handle != null) {
            data.handle = this.handle.toObject();
        }
        if (this.id != null) {
            data.id = this.id.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_handle)
            writer.writeMessage(1, this.handle, () => this.handle.serialize(writer));
        if (this.has_id)
            writer.writeMessage(2, this.id, () => this.id.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HandleIdRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HandleIdRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.handle, () => message.handle = Handle.deserialize(reader));
                    break;
                case 2:
                    reader.readMessage(message.id, () => message.id = Id.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): HandleIdRequest {
        return HandleIdRequest.deserialize(bytes);
    }
}
export class EmptyResponse extends pb_1.Message {
    #one_of_decls: number[][] = [[1]];
    constructor(data?: any[] | ({} & (({
        void?: boolean;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("void" in data && data.void != undefined) {
                this.void = data.void;
            }
        }
    }
    get void() {
        return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
    }
    set void(value: boolean) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_void() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get _void() {
        const cases: {
            [index: number]: "none" | "void";
        } = {
            0: "none",
            1: "void"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    static fromObject(data: {
        void?: boolean;
    }): EmptyResponse {
        const message = new EmptyResponse({});
        if (data.void != null) {
            message.void = data.void;
        }
        return message;
    }
    toObject() {
        const data: {
            void?: boolean;
        } = {};
        if (this.void != null) {
            data.void = this.void;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_void)
            writer.writeBool(1, this.void);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EmptyResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EmptyResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.void = reader.readBool();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): EmptyResponse {
        return EmptyResponse.deserialize(bytes);
    }
}
export class IdResponse extends pb_1.Message {
    #one_of_decls: number[][] = [[1]];
    constructor(data?: any[] | ({} & (({
        id?: Id;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("id" in data && data.id != undefined) {
                this.id = data.id;
            }
        }
    }
    get id() {
        return pb_1.Message.getWrapperField(this, Id, 1) as Id;
    }
    set id(value: Id) {
        pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_id() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get _id() {
        const cases: {
            [index: number]: "none" | "id";
        } = {
            0: "none",
            1: "id"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    static fromObject(data: {
        id?: ReturnType<typeof Id.prototype.toObject>;
    }): IdResponse {
        const message = new IdResponse({});
        if (data.id != null) {
            message.id = Id.fromObject(data.id);
        }
        return message;
    }
    toObject() {
        const data: {
            id?: ReturnType<typeof Id.prototype.toObject>;
        } = {};
        if (this.id != null) {
            data.id = this.id.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_id)
            writer.writeMessage(1, this.id, () => this.id.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IdResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IdResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.id, () => message.id = Id.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): IdResponse {
        return IdResponse.deserialize(bytes);
    }
}
export class BoolResponse extends pb_1.Message {
    #one_of_decls: number[][] = [[1]];
    constructor(data?: any[] | ({} & (({
        value?: boolean;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("value" in data && data.value != undefined) {
                this.value = data.value;
            }
        }
    }
    get value() {
        return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
    }
    set value(value: boolean) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_value() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get _value() {
        const cases: {
            [index: number]: "none" | "value";
        } = {
            0: "none",
            1: "value"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    static fromObject(data: {
        value?: boolean;
    }): BoolResponse {
        const message = new BoolResponse({});
        if (data.value != null) {
            message.value = data.value;
        }
        return message;
    }
    toObject() {
        const data: {
            value?: boolean;
        } = {};
        if (this.value != null) {
            data.value = this.value;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_value)
            writer.writeBool(1, this.value);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BoolResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BoolResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.value = reader.readBool();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): BoolResponse {
        return BoolResponse.deserialize(bytes);
    }
}
export class StringResponse extends pb_1.Message {
    #one_of_decls: number[][] = [[1]];
    constructor(data?: any[] | ({} & (({
        value?: string;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("value" in data && data.value != undefined) {
                this.value = data.value;
            }
        }
    }
    get value() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set value(value: string) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_value() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get _value() {
        const cases: {
            [index: number]: "none" | "value";
        } = {
            0: "none",
            1: "value"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    static fromObject(data: {
        value?: string;
    }): StringResponse {
        const message = new StringResponse({});
        if (data.value != null) {
            message.value = data.value;
        }
        return message;
    }
    toObject() {
        const data: {
            value?: string;
        } = {};
        if (this.value != null) {
            data.value = this.value;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_value)
            writer.writeString(1, this.value);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StringResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StringResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.value = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StringResponse {
        return StringResponse.deserialize(bytes);
    }
}
export class HandleResponse extends pb_1.Message {
    #one_of_decls: number[][] = [[1]];
    constructor(data?: any[] | ({} & (({
        value?: Handle;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("value" in data && data.value != undefined) {
                this.value = data.value;
            }
        }
    }
    get value() {
        return pb_1.Message.getWrapperField(this, Handle, 1) as Handle;
    }
    set value(value: Handle) {
        pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_value() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get _value() {
        const cases: {
            [index: number]: "none" | "value";
        } = {
            0: "none",
            1: "value"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    static fromObject(data: {
        value?: ReturnType<typeof Handle.prototype.toObject>;
    }): HandleResponse {
        const message = new HandleResponse({});
        if (data.value != null) {
            message.value = Handle.fromObject(data.value);
        }
        return message;
    }
    toObject() {
        const data: {
            value?: ReturnType<typeof Handle.prototype.toObject>;
        } = {};
        if (this.value != null) {
            data.value = this.value.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_value)
            writer.writeMessage(1, this.value, () => this.value.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HandleResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HandleResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.value, () => message.value = Handle.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): HandleResponse {
        return HandleResponse.deserialize(bytes);
    }
}
export class BufferResponse extends pb_1.Message {
    #one_of_decls: number[][] = [[1]];
    constructor(data?: any[] | ({} & (({
        value?: Uint8Array;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("value" in data && data.value != undefined) {
                this.value = data.value;
            }
        }
    }
    get value() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
    }
    set value(value: Uint8Array) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_value() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get _value() {
        const cases: {
            [index: number]: "none" | "value";
        } = {
            0: "none",
            1: "value"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    static fromObject(data: {
        value?: Uint8Array;
    }): BufferResponse {
        const message = new BufferResponse({});
        if (data.value != null) {
            message.value = data.value;
        }
        return message;
    }
    toObject() {
        const data: {
            value?: Uint8Array;
        } = {};
        if (this.value != null) {
            data.value = this.value;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_value)
            writer.writeBytes(1, this.value);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BufferResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BufferResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.value = reader.readBytes();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): BufferResponse {
        return BufferResponse.deserialize(bytes);
    }
}
export class StatusResponse extends pb_1.Message {
    #one_of_decls: number[][] = [[1]];
    constructor(data?: any[] | ({} & (({
        value?: number;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("value" in data && data.value != undefined) {
                this.value = data.value;
            }
        }
    }
    get value() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set value(value: number) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_value() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get _value() {
        const cases: {
            [index: number]: "none" | "value";
        } = {
            0: "none",
            1: "value"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    static fromObject(data: {
        value?: number;
    }): StatusResponse {
        const message = new StatusResponse({});
        if (data.value != null) {
            message.value = data.value;
        }
        return message;
    }
    toObject() {
        const data: {
            value?: number;
        } = {};
        if (this.value != null) {
            data.value = this.value;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_value)
            writer.writeInt32(1, this.value);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StatusResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StatusResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.value = reader.readInt32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StatusResponse {
        return StatusResponse.deserialize(bytes);
    }
}
